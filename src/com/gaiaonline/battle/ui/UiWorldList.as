package com.gaiaonline.battle.ui{	import com.gaiaonline.battle.news.INewsConnector;	import com.gaiaonline.battle.news.ITickerConnector;	import com.gaiaonline.battle.ui.UiWorldListClasses.FriendItem;	import com.gaiaonline.battle.ui.UiWorldListClasses.FriendsArea;	import com.gaiaonline.battle.ui.UiWorldListClasses.IFriendsListPanel;	import com.gaiaonline.battle.ui.UiWorldListClasses.INewsHolder;	import com.gaiaonline.battle.ui.UiWorldListClasses.IOptionsHolder;	import com.gaiaonline.battle.ui.UiWorldListClasses.ITickerHolder;	import com.gaiaonline.battle.ui.UiWorldListClasses.ITrailerButton;	import com.gaiaonline.battle.ui.UiWorldListClasses.IWorldListFooter;	import com.gaiaonline.battle.ui.UiWorldListClasses.ServerItem;	import com.gaiaonline.battle.ui.UiWorldListClasses.Ticker;	import com.gaiaonline.battle.ui.components.ScrollBarVer;	import com.gaiaonline.battle.ui.components.TabButton;	import com.gaiaonline.battle.ui.components.TabManager;	import com.gaiaonline.platform.serverSelect.IServerSelectUIHandler;	import com.gaiaonline.platform.ui.IWorldList;		import flash.events.IEventDispatcher;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Graphics;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.SimpleButton;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.filters.DropShadowFilter;	import flash.geom.Rectangle;		public class UiWorldList extends MovieClip implements IWorldList, IFriendsListPanel, ITrailerButton, ITickerHolder, INewsHolder, IWorldListFooter, IOptionsHolder	{		private static const SORT_FRIENDS:String = "friends";				private static const BG_PADDING_LEFT:Number = 10;		private static const BG_PADDING_RIGHT:Number = 10;		private static const BG_PADDING_TOP:Number = 10;		private static const BG_PADDING_BOTTOM:Number = 10;				public var uiNews:UiNews;				public var btnServerName:TabButton;				public var btnPer:TabButton;		public var mcServerList:Sprite;		private var _selectedItem:ServerItem;		public var scrServerList:ScrollBarVer;			public var btnConnect:SimpleButton;		public var ticker:Ticker;				public var _options:UiOptions;		public var _showIntroBtn:SimpleButton;			public var _voiceInstallButton:SimpleButton;					private var bg:Shape;		public var btnFriends:TabButton;		private static const SORT_SERVERNAME:String = "serverName";		private static const SORT_POPULATION:String = "pct"; // "population";		private static const SORT_POPMETER:String = "pct";		private var serverTabManager:TabManager;		private var serverItems:Array = new Array();		private var serverSortOption:uint = Array.NUMERIC;		private var serverSortParam:String = SORT_POPMETER;						private var _friendsArea:FriendsArea = null;		private var _uiHandlers:Array = [];		private var _backgroundIsValid:Boolean = true;		private var _trailerListeners:Array = [];		private var _optionsListeners:Array = [];		private var _worldListFooterListeners:Array = [];				public function UiWorldList()		{			this.tabChildren = false;						this.scrServerList.bigStep = 280;			this.scrServerList.init(this.mcServerList, new Rectangle(379,80,305,285));				this.scrServerList.smallStep = 20;						this.filters = [new DropShadowFilter(5,45,0x000000,1,5,5,0.75, 1)];						this.addEventListener(Event.ADDED_TO_STAGE, onAddedToStage, false, 0, true);			this.addEventListener(Event.REMOVED_FROM_STAGE, onRemoveFromStage, false, 0, true);						this.serverTabManager = new TabManager(true);			this.serverTabManager.addTabs(this.btnServerName, null, false);			this.serverTabManager.addTabs(this.btnPer, null, false);			this.btnPer.sortAscending = true;						this.btnServerName.addEventListener(MouseEvent.CLICK, onBtnServerNameClick, false, 0, true);								this.btnPer.addEventListener(MouseEvent.CLICK, onBtnPopMeterClick, false, 0, true);						this.btnConnect.addEventListener(MouseEvent.CLICK, onBtnConnectClick, false, 0, true);						invalidateBackground();		}				public function showTicker(tickerConnector:ITickerConnector):void {			ticker = new Ticker(tickerConnector);			ticker.x = 11;			ticker.y = 6;			addChild(ticker);			invalidateBackground();		}				public function showTrailerButton():void{			_showIntroBtn = new BtnPlayIntro();			_showIntroBtn.x = 11;			_showIntroBtn.y = 406;			_showIntroBtn.addEventListener(MouseEvent.CLICK, onBtnShowIntroClick, false, 0, true);			addChild(_showIntroBtn);						invalidateBackground();		}				public function showOptions(value:Boolean):void		{			_options = new UiOptions();			_options.x = 6;			_options.y = 320;			_options.preRender.checked = value;			_options.preRender.addEventListener(Event.CHANGE, onOptionsChange, false, 0, true);			addChild(_options);		}				public function showWorldListFooter():void		{			// [bgh] FS#36354 - Action Script Error #2044: Unhandled StatusEvent:. level=error, code= 			// it seems the event is firing before the swf has had a chance to create it's children. 			if(null != mcServerList && null != scrServerList)			{				_voiceInstallButton = new WorldListVoiceChat()				_voiceInstallButton.x = mcServerList.x;				_voiceInstallButton.y = scrServerList.y + scrServerList.height - _voiceInstallButton.height;								_voiceInstallButton.addEventListener(MouseEvent.CLICK, onWorldListFooterClick, false, 0, true);				addChild(_voiceInstallButton);			}		}				public function registerForWorldListFooterEvents(fxn:Function):void{			_worldListFooterListeners.push(fxn);		}		public function unregisterForWorldListFooterEvents(fxn:Function):void{			var len:uint = _worldListFooterListeners.length;			if(len == 1){				_worldListFooterListeners.length = 0;			}			else{				for(var i:uint; i<len; ++i){					if(fxn == _worldListFooterListeners[i]){						_worldListFooterListeners.splice(i, 1);					}				}			}		}				private function onWorldListFooterClick(evt:MouseEvent):void {			for each(var fxn:Function in _worldListFooterListeners){				fxn();			}		}				public function registerForOptionsEvents(fxn:Function):void{			_optionsListeners.push(fxn);		}		public function unregisterForOptionsEvents(fxn:Function):void{			var len:uint = _optionsListeners.length;			if(len == 1){				_optionsListeners.length = 0;			}			else{				for(var i:uint; i<len; ++i){					if(fxn == _optionsListeners[i]){						_optionsListeners.splice(i, 1);					}				}			}		}				public function registerForTrailerEvents(fxn:Function):void{			_trailerListeners.push(fxn);		}		public function unregisterForTrailerEvents(fxn:Function):void{			var len:uint = _trailerListeners.length;			if(len == 1){				_trailerListeners.length = 0;			}			else{				for(var i:uint; i<len; ++i){					if(fxn == _trailerListeners[i]){						_trailerListeners.splice(i, 1);					}				}			}		}				private function onOptionsChange(evt:Event):void {			for each(var fxn:Function in _optionsListeners){				fxn(_options.preRender.checked);			}		}		private function onBtnShowIntroClick(evt:MouseEvent):void {			for each(var fxn:Function in _trailerListeners){				fxn();			}		}				public function showFriends():void{			_friendsArea = new FriendsArea();			_friendsArea.x = 389;			_friendsArea.y = 380;			addChild(_friendsArea);			invalidateBackground();		}				public function showNews(newsConnector:INewsConnector, baseUrl:String, partnerId:String):void{			uiNews = new UiNews();			uiNews.x = 11;			uiNews.y = 37;			uiNews.init(newsConnector, baseUrl, partnerId);			addChild(uiNews);			invalidateBackground();		}				private function invalidateBackground():void{			if(_backgroundIsValid){				_backgroundIsValid = false;				addEventListener(Event.ENTER_FRAME, onEnterFrame, false, 0, true);			}			}				private function onEnterFrame(event:Event):void{			IEventDispatcher(event.target).removeEventListener(event.type, arguments.callee);			drawBackground();			_backgroundIsValid = true;		}				/**		 * this is kind of crappy.  We have some components with masks, so if the content is really tall, we get an inaccurate height.		 * Height includes content that's masked away; it's not the visible height.  To get the visible height we have a method that 		 * looks at bitmap snapshot to figure out how tall it is.  		 * 		 * If this proves to be a memory problem we can just hard code the value, but it's nice to have the flexibly changing layout.		 * [jtn]		 * 		 * */		private function getVisibleBounds (o:DisplayObject):Rectangle {					  if(bg){			bg.visible = false;		  }		  		  var bitmapDataSize:int = 1000;		  var bounds:Rectangle;		  var bitmapData:BitmapData = new BitmapData(bitmapDataSize, 		                                             bitmapDataSize,		                                             true,		                                             0);		  bitmapData.draw(o);		  bounds = bitmapData.getColorBoundsRect( 0xFF000000, 0x00000000, false );		  bitmapData.dispose(); 		  		   if(bg){			bg.visible = true;		  }		  		  return bounds;		}				private function drawBackground():void{//			var bounds:Rectangle = this.getBounds(this);			var bounds:Rectangle = this.getVisibleBounds(this);						if(!bg){				bg = new Shape()			}			bg.x = bounds.x - BG_PADDING_LEFT;			bg.y = bounds.y - BG_PADDING_TOP;						var bgGraphics:Graphics = bg.graphics;			bgGraphics.clear();			bgGraphics.beginFill(0);			bgGraphics.drawRect(0, 0, bounds.width + BG_PADDING_LEFT + BG_PADDING_RIGHT, bounds.height + BG_PADDING_TOP + BG_PADDING_BOTTOM);			bgGraphics.endFill();						addChildAt(bg, 0);			centerToStage();		}				public function get selectedItem():ServerItem{			return _selectedItem;		}				private function onAddedToStage(evt:Event):void{						this.centerToStage();			this.stage.addEventListener(Event.RESIZE, onResize, false, 0, true);			this.stage.addEventListener(KeyboardEvent.KEY_DOWN, _onKeyDown, false, 0, true);				if(ticker){				this.ticker.startTicker();			}				}		static private const s_emptyArray:Array = [];		private function onRemoveFromStage(evt:Event):void{			this.stage.removeEventListener(Event.RESIZE, onResize);			this.stage.removeEventListener(KeyboardEvent.KEY_DOWN, _onKeyDown);						this.refreshServers(s_emptyArray);			if(ticker){				this.ticker.stopTicker();			}		}		private function _onKeyDown(evt:KeyboardEvent):void{			if (evt.keyCode == 13){				this.onBtnConnectClick(new MouseEvent(MouseEvent.CLICK));			}		}		private function onResize(evt:Event):void{			this.centerToStage()		}				private function centerToStage():void{			if (bg && this.stage != null){				var bounds:Rectangle = this.getBounds(this);				//				this.x = (this.stage.stageWidth/2 - bounds.width/2);//				this.y = (this.stage.stageHeight/2 - bounds.height/2);								var bounds2:Rectangle = this.getBounds(bg);								this.x = (this.stage.stageWidth/2 - this.bg.width/2) - bg.x;				this.y = (this.stage.stageHeight/2 - this.bg.height/2) - bg.y;			}		}				private function sortColumn(btn:TabButton, sortField:String, bNumeric:Boolean):void		{			var options:uint = bNumeric ? Array.NUMERIC : 0;			if (!btn.sortAscending)			{				options |= Array.DESCENDING;			}			this.sortServerOn(sortField, options);		}		private function onBtnServerNameClick(evt:MouseEvent):void{			this.sortColumn(this.btnServerName, SORT_SERVERNAME, false);		}		private function onBtnPopMeterClick(evt:MouseEvent):void{			this.sortColumn(this.btnPer, SORT_POPMETER, true);		} 				private function onItemSelected(evt:Event):void{			for (var i:int = 0; i < this.serverItems.length; i++){				if (this.serverItems[i] == evt.target){					_selectedItem = this.serverItems[i];				}else{					ServerItem(this.serverItems[i]).selected = false;				}			}		}				private function onBtnConnectClick(evt:MouseEvent):void{			if (this.selectedItem != null){				for each(var handler:IServerSelectUIHandler in _uiHandlers){					handler.onServerSelected(selectedItem.serverName, selectedItem.id, selectedItem.ip, selectedItem.port);				}			}		}				private function scrollServerItemIntoView(item:ServerItem):void{			if (item != null && this.mcServerList.contains(item) && (item.y + item.height) > this.scrServerList.height){												this.scrServerList.scroll( (item.y -  (this.scrServerList.height - item.height)) * (this.scrServerList.height/this.mcServerList.height)   )			}		}				public function selectBestServer():void{			var items:Array = this.serverItems.concat();			if (items != null && items.length > 0){				items.sortOn(["pct", "id"],[Array.NUMERIC, Array.NUMERIC]);			}			if (this.selectedItem != null){				this.selectedItem.selected = false;			}						if (items.length > 0) {				_selectedItem = items[0];				this.selectedItem.selected = true;				this.scrollServerItemIntoView(this.selectedItem);			}		}					private function addServerItem(item:ServerItem, updateSort:Boolean = true):void{			if (this.serverItems.indexOf(item) < 0){				item.addEventListener("Selected", onItemSelected, false, 0, true);				this.serverItems.push(item);								this.mcServerList.addChild(item);								if (updateSort){					this.sortServerOn(this.serverSortParam, this.serverSortOption);					this.scrServerList.update();				}							}		}				private function removerServerItem(item:ServerItem, updateSort:Boolean = true):void{			if (this.selectedItem == item){				_selectedItem = null;			}			if (this.mcServerList.contains(item)){				this.mcServerList.removeChild(item);										}			var i:int = this.serverItems.indexOf(item);			if (i >= 0){				this.serverItems.splice(i,1);			}			if (updateSort){				this.scrServerList.update();			}					}				private function sortServerOn(param:String, options:uint):void{			this.serverSortOption = options;			this.serverSortParam = param;			this.serverItems.sortOn([param, "id"], this.serverSortOption | Array.CASEINSENSITIVE);			for (var i:int = 0; i < this.serverItems.length; i++){				//trace(ServerItem(this.serverItems[i]).population, ServerItem(this.serverItems[i]).pct);				this.serverItems[i].y = i * 20;			}					}				public function refreshServers(servers:Array):void{			// Update existing and Add New			for (var i:int = 0; i < servers.length; i++){				var exists:Boolean = false;				for (var ii:int = 0; ii < this.serverItems.length; ii++){					if (servers[i].id == this.serverItems[ii].id){						exists = true;						this.serverItems[ii].ip = servers[i].ip;						this.serverItems[ii].port = servers[i].port;						this.serverItems[ii].serverName = servers[i].serverName;						this.serverItems[ii].population = servers[i].population;						this.serverItems[ii].maxPop = servers[i].maxPop;						break;																}				}				if (!exists){					var nItem:ServerItem = new ServerItem();					nItem.id = servers[i].id;					nItem.ip = servers[i].ip;					nItem.port = servers[i].port;					nItem.serverName = servers[i].serverName;					nItem.population = servers[i].population;					nItem.maxPop = servers[i].maxPop;					this.addServerItem(nItem, false);				}			}									//--  find item that need to be remove						var itemsToRemove:Array = new Array();			for (var n:int = 0; n < this.serverItems.length; n++){				var ok:Boolean = false;				for (var nn:int = 0; nn < servers.length; nn++){					if (this.serverItems[n].id == servers[nn].id){						ok = true;						break;					}				}				if (!ok){					itemsToRemove.push(this.serverItems[n]);				}			}									// remove serverItems that need to be remove				for (var r:int = 0; r < itemsToRemove.length; r++){				this.removerServerItem(itemsToRemove[r], false);			}									// resort the list			this.sortServerOn(this.serverSortParam, this.serverSortOption);									/* if (this.selectedItem == null && this.serverItems.length > 0){				this.selectBestServer();			} */						this.scrServerList.update();			this.scrollServerItemIntoView(this.selectedItem);		}				public function selectServerId(serverId:String):void{			for (var i:int = 0; i < this.serverItems.length; i++){				if (this.serverItems[i].id == serverId){					if (this.selectedItem != null){						this.selectedItem.selected = false;					}					_selectedItem = this.serverItems[i];					ServerItem(this.serverItems[i]).selected = true;														break;				}			}						if (this.selectedItem == null){				this.selectBestServer();			}else{				this.scrollServerItemIntoView(this.selectedItem);			}								}						public function registerForServerSelect(handler:IServerSelectUIHandler):void{			if(_uiHandlers.indexOf(handler) == -1){				_uiHandlers.push(handler);			}		}		public function unregisterForServerSelect(handler:IServerSelectUIHandler):void{			var len:uint = _uiHandlers.length			if(len <= 1){				_uiHandlers.length = 0;			}			else{				for(var i:uint=0; i<len; ++i){					if(_uiHandlers[i] == handler){						_uiHandlers.splice(i, 1);						return;					}				}			}		}				//--------- Friends List		public function removerFriendItem(item:FriendItem, updateSort:Boolean = true):void{			_friendsArea.removerFriendItem(item, updateSort);		}				public function refreshFriendsList(friends:Array):void{			if(_friendsArea){				_friendsArea.refreshFriendsList(friends);			}		}	}}